package repositories

import (
	"context"
	"database/sql"
	"fmt"
	internalerrors "github.com/chempik1234/L3.1-wb-tech-school/delayed_notifier/internal/errors"
	"github.com/chempik1234/L3.1-wb-tech-school/delayed_notifier/internal/internaltypes"
	"github.com/wb-go/wbf/zlog"
	"strconv"
	"strings"
	"time"

	"github.com/wb-go/wbf/dbpg"
	"github.com/wb-go/wbf/retry"

	"github.com/chempik1234/L3.1-wb-tech-school/delayed_notifier/internal/models"
	"github.com/chempik1234/L3.1-wb-tech-school/delayed_notifier/pkg/types"
)

// NotificationPostgres implements ports.NotificationCRUDStorageRepository and ports.NotificationFetcherRepository
//
// Postgres implementation with dbpg.DB
type NotificationPostgres struct {
	db       *dbpg.DB
	strategy retry.Strategy
}

// NewNotificationPostgres creates a new NotificationPostgres
func NewNotificationPostgres(db *dbpg.DB, retryStrategy retry.Strategy) *NotificationPostgres {
	return &NotificationPostgres{db: db, strategy: retryStrategy}
}

// CreateNotification is the Create method of this DB CRUD
//
// uuid is generated by caller
func (r *NotificationPostgres) CreateNotification(ctx context.Context, notification *models.Notification) error {
	query := `
        INSERT INTO delayed_notifier.delayed_notifier.notifications (id, channel, publication_at, title, message, sent_to_worker, send_to) 
        VALUES ($1, $2, $3, $4, $5, $6, $7)`

	_, err := r.db.ExecWithRetry(ctx, r.strategy, query, notification.ID.String(), notification.Channel.String(), notification.PublicationAt.String(), notification.Content.Title.String(), notification.Content.Message.String(), notification.Sent, notification.SendTo.String())
	if err != nil {
		return err
	}

	return nil
}

// UpdateNotification is the Update method of this DB CRUD
//
// existing object's uuid is received from *models.Notification
func (r *NotificationPostgres) UpdateNotification(ctx context.Context, newData *models.Notification) error {
	query := `
        UPDATE delayed_notifier.delayed_notifier.notifications
        SET channel = $1, publication_at = $2, title = $3, message = $4, sent_to_worker = $5, send_to = $6, updated_at = now()
        WHERE id = $7`

	res, err := r.db.ExecWithRetry(ctx, r.strategy, query, newData.Channel.String(), newData.PublicationAt.String(), newData.Content.Title.String(), newData.Content.Message.String(), newData.Sent, newData.SendTo.String(), newData.ID.String())
	if err != nil {
		return err
	}

	var rowsAffected int64
	rowsAffected, err = res.RowsAffected()
	if err != nil {
		return fmt.Errorf("couldn't get number of rows affected: %v", err)
	}

	if rowsAffected == 0 {
		return internalerrors.ErrNotificationNotFound
	}
	return nil
}

// DeleteNotification deletes a row by ID, err on not found
func (r *NotificationPostgres) DeleteNotification(ctx context.Context, id types.UUID) error {
	query := `DELETE FROM delayed_notifier.delayed_notifier.notifications WHERE id = $1`
	res, err := r.db.ExecWithRetry(ctx, r.strategy, query, id.String())
	if err != nil {
		return err
	}

	var rowsAffected int64
	rowsAffected, err = res.RowsAffected()
	if err != nil {
		return fmt.Errorf("couldn't get number of rows affected: %v", err)
	}

	if rowsAffected == 0 {
		return internalerrors.ErrNotificationNotFound
	}
	return nil
}

// GetNotification retrieves an object by ID, err on not found
func (r *NotificationPostgres) GetNotification(ctx context.Context, id types.UUID) (*models.Notification, error) {
	query := `SELECT channel, publication_at, title, message, sent_to_worker, send_to FROM delayed_notifier.delayed_notifier.notifications WHERE id = $1`

	row, err := r.db.QueryRowWithRetry(ctx, r.strategy, query, id.String())
	if err != nil {
		return nil, fmt.Errorf("error select by id in postgres: %w", err)
	}

	var channel string
	var publishedAt time.Time
	var title, message string
	var sent bool
	var sendTo string
	if err = row.Scan(&channel, &publishedAt, &title, &message, &sent, &sendTo); err != nil {
		return nil, err
	}

	var channelValid internaltypes.NotificationChannel
	channelValid, err = internaltypes.NotificationChannelFromString(channel)
	if err != nil {
		return nil, fmt.Errorf("invalid channel in postgres: %w", err)
	}

	var sendToValid internaltypes.SendTo
	sendToValid, err = internaltypes.NewSendTo(types.NewAnyText(sendTo), channelValid)
	if err != nil {
		return nil, fmt.Errorf("invalid send_to in postgres: %w", err)
	}

	return &models.Notification{
		PublicationAt: types.NewDateTime(publishedAt),
		ID:            &id,
		Channel:       channelValid,
		Sent:          sent,
		Content: models.NotificationContent{
			Title:   types.AnyText(title),
			Message: types.AnyText(message),
		},
		SendTo: sendToValid,
	}, nil
}

// Fetch fetches objects to be sent (only up to maxPublicationAt not to store everything in memory)
//
// fetches are supposed to be done regularly
func (r *NotificationPostgres) Fetch(ctx context.Context, maxPublicationAt types.DateTime) ([]*models.Notification, error) {
	query := `SELECT id, channel, publication_at, title, message, sent_to_worker, send_to FROM delayed_notifier.delayed_notifier.notifications WHERE publication_at <= $1 AND sent_to_worker = false ORDER BY publication_at`

	rows, err := r.db.QueryWithRetry(ctx, r.strategy, query, maxPublicationAt.String())
	if err != nil {
		return nil, fmt.Errorf("error fetching in postgres up to datetime '%s': %w", maxPublicationAt.String(), err)
	}

	defer func(rows *sql.Rows) {
		if closeErr := rows.Close(); closeErr != nil {
			zlog.Logger.Error().Err(err).Msg("couldn't close postgres rows when fetching")
		}
	}(rows)

	// save both notifications and their IDS for status updating
	notifications := make([]*models.Notification, 0)

	for rows.Next() {

		var idString string
		var channel string
		var publishedAt time.Time
		var title, message string
		var sent bool
		var sendTo string

		if err = rows.Scan(&idString, &channel, &publishedAt, &title, &message, &sent, &sendTo); err != nil {
			return nil, fmt.Errorf("error scanning row in fetch: %w", err)
		}

		var channelValid internaltypes.NotificationChannel
		channelValid, err = internaltypes.NotificationChannelFromString(channel)
		if err != nil {
			zlog.Logger.Error().Err(fmt.Errorf("invalid channel in postgres: %w", err))
			continue
		}

		var sendToValid internaltypes.SendTo
		sendToValid, err = internaltypes.NewSendTo(types.NewAnyText(sendTo), channelValid)
		if err != nil {
			return nil, fmt.Errorf("invalid send_to in postgres: %w", err)
		}

		var id types.UUID
		id, err = types.NewUUID(idString)
		if err != nil {
			zlog.Logger.Error().Err(fmt.Errorf("invalid uuid in postgres: %w", err))
			continue
		}

		notifications = append(notifications, &models.Notification{
			PublicationAt: types.NewDateTime(publishedAt),
			ID:            &id,
			Channel:       channelValid,
			Content: models.NotificationContent{
				Title:   types.AnyText(title),
				Message: types.AnyText(message),
			},
			Sent:   sent,
			SendTo: sendToValid,
		})
	}

	return notifications, nil
}

// MarkAsSent should be used to mark fetched notifications as sent
func (r *NotificationPostgres) MarkAsSent(ctx context.Context, ids []*types.UUID) error {
	idsNumsList := make([]string, len(ids))
	for i := range ids {
		idsNumsList[i] = "$" + strconv.Itoa(i+1)
	}
	query := fmt.Sprintf(`UPDATE delayed_notifier.delayed_notifier.notifications SET sent_to_worker = true where id IN (%s)`, strings.Join(idsNumsList, ","))

	// requires to convert: []types.UUID to []string to ('string1', 'string2', ....)
	//
	// allocations and everything... unfortunately
	idsStrings := make([]any, len(ids))
	for i, id := range ids {
		idsStrings[i] = id.String()
	}

	// exec
	_, err := r.db.ExecWithRetry(ctx, r.strategy, query, idsStrings...)
	if err != nil {
		return fmt.Errorf("error marking %d notifications as sent: %w", len(ids), err)
	}

	// we could also check if RowsAffected = len(ids) but that's wrong
	// what if rows were deleted while sending notifications?

	return nil
}
